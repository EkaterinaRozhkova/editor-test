import {
  katex
} from "./chunk-FAZOTWSJ.js";
import {
  Extension,
  InputRule,
  Node3,
  mergeAttributes
} from "./chunk-3GBD4E7R.js";
import "./chunk-5WRI5ZAA.js";

// node_modules/@tiptap/extension-mathematics/dist/index.js
var BlockMath = Node3.create({
  name: "blockMath",
  group: "block",
  atom: true,
  addOptions() {
    return {
      onClick: void 0,
      katexOptions: void 0
    };
  },
  addAttributes() {
    return {
      latex: {
        default: "",
        parseHTML: (element) => element.getAttribute("data-latex"),
        renderHTML: (attributes) => {
          return {
            "data-latex": attributes.latex
          };
        }
      }
    };
  },
  addCommands() {
    return {
      insertBlockMath: (options) => ({ commands, editor }) => {
        const { latex, pos } = options;
        if (!latex) {
          return false;
        }
        return commands.insertContentAt(pos != null ? pos : editor.state.selection.from, {
          type: this.name,
          attrs: { latex }
        });
      },
      deleteBlockMath: (options) => ({ editor, tr }) => {
        var _a;
        const pos = (_a = options == null ? void 0 : options.pos) != null ? _a : editor.state.selection.$from.pos;
        const node = editor.state.doc.nodeAt(pos);
        if (!node || node.type.name !== this.name) {
          return false;
        }
        tr.delete(pos, pos + node.nodeSize);
        return true;
      },
      updateBlockMath: (options) => ({ editor, tr }) => {
        const latex = options == null ? void 0 : options.latex;
        let pos = options == null ? void 0 : options.pos;
        if (pos === void 0) {
          pos = editor.state.selection.$from.pos;
        }
        const node = editor.state.doc.nodeAt(pos);
        if (!node || node.type.name !== this.name) {
          return false;
        }
        tr.setNodeMarkup(pos, this.type, {
          ...node.attrs,
          latex: latex || node.attrs.latex
        });
        return true;
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: 'div[data-type="block-math"]'
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["div", mergeAttributes(HTMLAttributes, { "data-type": "block-math" })];
  },
  parseMarkdown: (token) => {
    return {
      type: "blockMath",
      attrs: {
        latex: token.latex
      }
    };
  },
  renderMarkdown: (node) => {
    var _a;
    const latex = ((_a = node.attrs) == null ? void 0 : _a.latex) || "";
    const output = ["$$", latex, "$$"];
    return output.join("\n");
  },
  markdownTokenizer: {
    name: "blockMath",
    level: "block",
    start: (src) => src.indexOf("$$"),
    tokenize: (src) => {
      const match = src.match(/^\$\$([^$]+)\$\$/);
      if (!match) {
        return void 0;
      }
      const [fullMatch, latex] = match;
      return {
        type: "blockMath",
        raw: fullMatch,
        latex: latex.trim()
      };
    }
  },
  addInputRules() {
    return [
      new InputRule({
        find: /^\$\$\$([^$]+)\$\$\$$/,
        handler: ({ state, range, match }) => {
          const [, latex] = match;
          const { tr } = state;
          const start = range.from;
          const end = range.to;
          tr.replaceWith(start, end, this.type.create({ latex }));
        }
      })
    ];
  },
  addNodeView() {
    const { katexOptions } = this.options;
    return ({ node, getPos }) => {
      const wrapper = document.createElement("div");
      const innerWrapper = document.createElement("div");
      wrapper.className = "tiptap-mathematics-render";
      if (this.editor.isEditable) {
        wrapper.classList.add("tiptap-mathematics-render--editable");
      }
      innerWrapper.className = "block-math-inner";
      wrapper.dataset.type = "block-math";
      wrapper.setAttribute("data-latex", node.attrs.latex);
      wrapper.appendChild(innerWrapper);
      function renderMath() {
        try {
          katex.render(node.attrs.latex, innerWrapper, katexOptions);
          wrapper.classList.remove("block-math-error");
        } catch {
          wrapper.textContent = node.attrs.latex;
          wrapper.classList.add("block-math-error");
        }
      }
      const handleClick = (event) => {
        event.preventDefault();
        event.stopPropagation();
        const pos = getPos();
        if (pos == null) {
          return;
        }
        if (this.options.onClick) {
          this.options.onClick(node, pos);
        }
      };
      if (this.options.onClick) {
        wrapper.addEventListener("click", handleClick);
      }
      renderMath();
      return {
        dom: wrapper,
        destroy() {
          wrapper.removeEventListener("click", handleClick);
        }
      };
    };
  }
});
var InlineMath = Node3.create({
  name: "inlineMath",
  group: "inline",
  inline: true,
  atom: true,
  addOptions() {
    return {
      onClick: void 0,
      katexOptions: void 0
    };
  },
  addAttributes() {
    return {
      latex: {
        default: "",
        parseHTML: (element) => element.getAttribute("data-latex"),
        renderHTML: (attributes) => {
          return {
            "data-latex": attributes.latex
          };
        }
      }
    };
  },
  addCommands() {
    return {
      insertInlineMath: (options) => ({ editor, tr }) => {
        var _a;
        const latex = options.latex;
        const from = (_a = options == null ? void 0 : options.pos) != null ? _a : editor.state.selection.from;
        if (!latex) {
          return false;
        }
        tr.replaceWith(from, from, this.type.create({ latex }));
        return true;
      },
      deleteInlineMath: (options) => ({ editor, tr }) => {
        var _a;
        const pos = (_a = options == null ? void 0 : options.pos) != null ? _a : editor.state.selection.$from.pos;
        const node = editor.state.doc.nodeAt(pos);
        if (!node || node.type.name !== this.name) {
          return false;
        }
        tr.delete(pos, pos + node.nodeSize);
        return true;
      },
      updateInlineMath: (options) => ({ editor, tr }) => {
        const latex = options == null ? void 0 : options.latex;
        let pos = options == null ? void 0 : options.pos;
        if (pos === void 0) {
          pos = editor.state.selection.$from.pos;
        }
        const node = editor.state.doc.nodeAt(pos);
        if (!node || node.type.name !== this.name) {
          return false;
        }
        tr.setNodeMarkup(pos, this.type, { ...node.attrs, latex });
        return true;
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: 'span[data-type="inline-math"]'
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["span", mergeAttributes(HTMLAttributes, { "data-type": "inline-math" })];
  },
  parseMarkdown: (token) => {
    return {
      type: "inlineMath",
      attrs: {
        latex: token.latex
      }
    };
  },
  renderMarkdown: (node) => {
    var _a;
    const latex = ((_a = node.attrs) == null ? void 0 : _a.latex) || "";
    return `$${latex}$`;
  },
  markdownTokenizer: {
    name: "inlineMath",
    level: "inline",
    start: (src) => src.indexOf("$"),
    tokenize: (src) => {
      const match = src.match(/^\$([^$]+)\$(?!\$)/);
      if (!match) {
        return void 0;
      }
      const [fullMatch, latex] = match;
      return {
        type: "inlineMath",
        raw: fullMatch,
        latex: latex.trim()
      };
    }
  },
  addInputRules() {
    return [
      new InputRule({
        find: /(^|[^$])(\$\$([^$\n]+?)\$\$)(?!\$)/,
        handler: ({ state, range, match }) => {
          const latex = match[3];
          const { tr } = state;
          const start = range.from;
          const end = range.to;
          tr.replaceWith(start, end, this.type.create({ latex }));
        }
      })
    ];
  },
  addNodeView() {
    const { katexOptions } = this.options;
    return ({ node, getPos }) => {
      const wrapper = document.createElement("span");
      wrapper.className = "tiptap-mathematics-render";
      if (this.editor.isEditable) {
        wrapper.classList.add("tiptap-mathematics-render--editable");
      }
      wrapper.dataset.type = "inline-math";
      wrapper.setAttribute("data-latex", node.attrs.latex);
      function renderMath() {
        try {
          katex.render(node.attrs.latex, wrapper, katexOptions);
          wrapper.classList.remove("inline-math-error");
        } catch {
          wrapper.textContent = node.attrs.latex;
          wrapper.classList.add("inline-math-error");
        }
      }
      const handleClick = (event) => {
        event.preventDefault();
        event.stopPropagation();
        const pos = getPos();
        if (pos == null) {
          return;
        }
        if (this.options.onClick) {
          this.options.onClick(node, pos);
        }
      };
      if (this.options.onClick) {
        wrapper.addEventListener("click", handleClick);
      }
      renderMath();
      return {
        dom: wrapper,
        destroy() {
          wrapper.removeEventListener("click", handleClick);
        }
      };
    };
  }
});
var Mathematics = Extension.create({
  name: "Mathematics",
  addOptions() {
    return {
      inlineOptions: void 0,
      blockOptions: void 0,
      katexOptions: void 0
    };
  },
  addExtensions() {
    return [
      BlockMath.configure({ ...this.options.blockOptions, katexOptions: this.options.katexOptions }),
      InlineMath.configure({ ...this.options.inlineOptions, katexOptions: this.options.katexOptions })
    ];
  }
});
var mathMigrationRegex = /\$(?!\d+\$)(.+?)\$(?!\d)/g;
function createMathMigrateTransaction(editor, tr, regex = mathMigrationRegex) {
  tr.doc.descendants((node, pos) => {
    if (!node.isText || !node.text || !node.text.includes("$")) {
      return;
    }
    const { text } = node;
    const match = node.text.match(regex);
    if (!match) {
      return;
    }
    match.forEach((mathMatch) => {
      const start = text.indexOf(mathMatch);
      const end = start + mathMatch.length;
      const from = tr.mapping.map(pos + start);
      const $from = tr.doc.resolve(from);
      const parent = $from.parent;
      const index = $from.index();
      const { inlineMath } = editor.schema.nodes;
      if (!parent.canReplaceWith(index, index + 1, inlineMath)) {
        return;
      }
      tr.replaceWith(
        tr.mapping.map(pos + start),
        tr.mapping.map(pos + end),
        inlineMath.create({ latex: mathMatch.slice(1, -1) })
      );
    });
  });
  tr.setMeta("addToHistory", false);
  return tr;
}
function migrateMathStrings(editor, regex = mathMigrationRegex) {
  const tr = createMathMigrateTransaction(editor, editor.state.tr, regex);
  editor.view.dispatch(tr);
}
var index_default = Mathematics;
export {
  BlockMath,
  InlineMath,
  Mathematics,
  createMathMigrateTransaction,
  index_default as default,
  mathMigrationRegex,
  migrateMathStrings
};
//# sourceMappingURL=@tiptap_extension-mathematics.js.map
