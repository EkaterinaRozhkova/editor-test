{
  "version": 3,
  "sources": ["../../@tiptap/extension-mathematics/src/mathematics.ts", "../../@tiptap/extension-mathematics/src/extensions/BlockMath.ts", "../../@tiptap/extension-mathematics/src/extensions/InlineMath.ts", "../../@tiptap/extension-mathematics/src/utils.ts", "../../@tiptap/extension-mathematics/src/index.ts"],
  "sourcesContent": ["import { Extension } from '@tiptap/core'\n\nimport { BlockMath, InlineMath } from './extensions/index.js'\nimport type { MathematicsOptions } from './types.js'\n\n/**\n * Mathematics extension for Tiptap that provides both inline and block math support using KaTeX.\n * This extension combines the InlineMath and BlockMath extensions to provide a complete\n * mathematical expression solution for rich text editing. It supports LaTeX syntax,\n * custom rendering options, and interactive math nodes.\n *\n * @example\n * ```typescript\n * import { Editor } from '@tiptap/core'\n * import { Mathematics } from '@tiptap/extension-mathematics'\n * import { migrateMathStrings } from '@tiptap/extension-mathematics/utils'\n *\n * const editor = new Editor({\n *   extensions: [\n *     Mathematics.configure({\n *       inlineOptions: {\n *         onClick: (node, pos) => {\n *           console.log('Inline math clicked:', node.attrs.latex)\n *         }\n *       },\n *       blockOptions: {\n *         onClick: (node, pos) => {\n *           console.log('Block math clicked:', node.attrs.latex)\n *         }\n *       },\n *       katexOptions: {\n *         displayMode: false,\n *         throwOnError: false,\n *         macros: {\n *           '\\\\RR': '\\\\mathbb{R}',\n *           '\\\\ZZ': '\\\\mathbb{Z}'\n *         }\n *       }\n *     })\n *   ],\n *   content: `\n *     <p>Inline math: $E = mc^2$</p>\n *     <div data-type=\"block-math\" data-latex=\"\\\\sum_{i=1}^{n} x_i = X\"></div>\n *   `,\n *   onCreate({ editor }) {\n *     // Optional: Migrate existing math strings to math nodes\n *     migrateMathStrings(editor)\n *   }\n * })\n * ```\n */\nexport const Mathematics = Extension.create<MathematicsOptions>({\n  name: 'Mathematics',\n\n  addOptions() {\n    return {\n      inlineOptions: undefined,\n      blockOptions: undefined,\n      katexOptions: undefined,\n    }\n  },\n\n  addExtensions() {\n    return [\n      BlockMath.configure({ ...this.options.blockOptions, katexOptions: this.options.katexOptions }),\n      InlineMath.configure({ ...this.options.inlineOptions, katexOptions: this.options.katexOptions }),\n    ]\n  },\n})\n\nexport default Mathematics\n", "import { InputRule, mergeAttributes, Node } from '@tiptap/core'\nimport type { Node as PMNode } from '@tiptap/pm/model'\nimport katex, { type KatexOptions } from 'katex'\n\n/**\n * Configuration options for the BlockMath extension.\n */\nexport type BlockMathOptions = {\n  /**\n   * KaTeX specific options\n   * @see https://katex.org/docs/options.html\n   * @example\n   * ```ts\n   * katexOptions: {\n   *   displayMode: true,\n   *   throwOnError: false,\n   * },\n   */\n  katexOptions?: KatexOptions\n\n  /**\n   * Optional click handler for block math nodes.\n   * Called when a user clicks on a block math expression in the editor.\n   *\n   * @param node - The ProseMirror node representing the block math element\n   * @param pos - The position of the node within the document\n   * @example\n   * ```ts\n   * onClick: (node, pos) => {\n   *   console.log('Block math clicked:', node.attrs.latex, 'at position:', pos)\n   * },\n   * ```\n   */\n  onClick?: (node: PMNode, pos: number) => void\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    insertBlockMath: {\n      /**\n       * Inserts a math block node with LaTeX string.\n       * @param options - Options for inserting block math.\n       * @returns ReturnType\n       */\n      insertBlockMath: (options: { latex: string; pos?: number }) => ReturnType\n\n      /**\n       * Deletes a block math node.\n       * @returns ReturnType\n       */\n      deleteBlockMath: (options?: { pos?: number }) => ReturnType\n\n      /**\n       * Update block math node with optional LaTeX string.\n       * @param options - Options for updating block math.\n       * @returns ReturnType\n       */\n      updateBlockMath: (options?: { latex: string; pos?: number }) => ReturnType\n    }\n  }\n}\n\n/**\n * BlockMath is a Tiptap extension for rendering block mathematical expressions using KaTeX.\n * It allows users to insert LaTeX formatted math expressions block within text.\n * It supports rendering, input rules for LaTeX syntax, and click handling for interaction.\n *\n * @example\n * ```javascript\n * import { BlockMath } from '@tiptap/extension-mathematics'\n * import { Editor } from '@tiptap/core'\n *\n * const editor = new Editor({\n *   extensions: [\n *     BlockMath.configure({\n *       onClick: (node, pos) => {\n *         console.log('Block math clicked:', node.attrs.latex, 'at position:', pos)\n *       },\n *     }),\n *   ],\n * })\n */\nexport const BlockMath = Node.create<BlockMathOptions>({\n  name: 'blockMath',\n\n  group: 'block',\n\n  atom: true,\n\n  addOptions() {\n    return {\n      onClick: undefined,\n      katexOptions: undefined,\n    }\n  },\n\n  addAttributes() {\n    return {\n      latex: {\n        default: '',\n        parseHTML: element => element.getAttribute('data-latex'),\n        renderHTML: attributes => {\n          return {\n            'data-latex': attributes.latex,\n          }\n        },\n      },\n    }\n  },\n\n  addCommands() {\n    return {\n      insertBlockMath:\n        options =>\n        ({ commands, editor }) => {\n          const { latex, pos } = options\n\n          if (!latex) {\n            return false\n          }\n\n          return commands.insertContentAt(pos ?? editor.state.selection.from, {\n            type: this.name,\n            attrs: { latex },\n          })\n        },\n\n      deleteBlockMath:\n        options =>\n        ({ editor, tr }) => {\n          const pos = options?.pos ?? editor.state.selection.$from.pos\n          const node = editor.state.doc.nodeAt(pos)\n\n          if (!node || node.type.name !== this.name) {\n            return false\n          }\n\n          tr.delete(pos, pos + node.nodeSize)\n          return true\n        },\n\n      updateBlockMath:\n        options =>\n        ({ editor, tr }) => {\n          const latex = options?.latex\n          let pos = options?.pos\n\n          if (pos === undefined) {\n            pos = editor.state.selection.$from.pos\n          }\n\n          const node = editor.state.doc.nodeAt(pos)\n\n          if (!node || node.type.name !== this.name) {\n            return false\n          }\n\n          tr.setNodeMarkup(pos, this.type, {\n            ...node.attrs,\n            latex: latex || node.attrs.latex,\n          })\n\n          return true\n        },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'div[data-type=\"block-math\"]',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['div', mergeAttributes(HTMLAttributes, { 'data-type': 'block-math' })]\n  },\n\n  parseMarkdown: (token: any) => {\n    return {\n      type: 'blockMath',\n      attrs: {\n        latex: token.latex,\n      },\n    }\n  },\n\n  renderMarkdown: node => {\n    const latex = node.attrs?.latex || ''\n\n    const output = ['$$', latex, '$$']\n    return output.join('\\n')\n  },\n\n  markdownTokenizer: {\n    name: 'blockMath',\n    level: 'block',\n    start: (src: string) => src.indexOf('$$'),\n    tokenize: (src: string) => {\n      // Match $$latex$$ syntax for block math\n      const match = src.match(/^\\$\\$([^$]+)\\$\\$/)\n      if (!match) {\n        return undefined\n      }\n\n      const [fullMatch, latex] = match\n\n      return {\n        type: 'blockMath',\n        raw: fullMatch,\n        latex: latex.trim(),\n      }\n    },\n  },\n\n  addInputRules() {\n    return [\n      new InputRule({\n        find: /^\\$\\$\\$([^$]+)\\$\\$\\$$/,\n        handler: ({ state, range, match }) => {\n          const [, latex] = match\n          const { tr } = state\n          const start = range.from\n          const end = range.to\n\n          tr.replaceWith(start, end, this.type.create({ latex }))\n        },\n      }),\n    ]\n  },\n\n  addNodeView() {\n    const { katexOptions } = this.options\n\n    return ({ node, getPos }) => {\n      const wrapper = document.createElement('div')\n      const innerWrapper = document.createElement('div')\n      wrapper.className = 'tiptap-mathematics-render'\n\n      if (this.editor.isEditable) {\n        wrapper.classList.add('tiptap-mathematics-render--editable')\n      }\n\n      innerWrapper.className = 'block-math-inner'\n      wrapper.dataset.type = 'block-math'\n      wrapper.setAttribute('data-latex', node.attrs.latex)\n      wrapper.appendChild(innerWrapper)\n\n      function renderMath() {\n        try {\n          katex.render(node.attrs.latex, innerWrapper, katexOptions)\n          wrapper.classList.remove('block-math-error')\n        } catch {\n          wrapper.textContent = node.attrs.latex\n          wrapper.classList.add('block-math-error')\n        }\n      }\n\n      const handleClick = (event: MouseEvent) => {\n        event.preventDefault()\n        event.stopPropagation()\n        const pos = getPos()\n\n        if (pos == null) {\n          return\n        }\n\n        if (this.options.onClick) {\n          this.options.onClick(node, pos)\n        }\n      }\n\n      if (this.options.onClick) {\n        wrapper.addEventListener('click', handleClick)\n      }\n\n      renderMath()\n\n      return {\n        dom: wrapper,\n        destroy() {\n          wrapper.removeEventListener('click', handleClick)\n        },\n      }\n    }\n  },\n})\n", "import { InputRule, mergeAttributes, Node } from '@tiptap/core'\nimport type { Node as PMNode } from '@tiptap/pm/model'\nimport katex, { type KatexOptions } from 'katex'\n\n/**\n * Configuration options for the InlineMath extension.\n */\nexport type InlineMathOptions = {\n  /**\n   * KaTeX specific options\n   * @see https://katex.org/docs/options.html\n   * @example\n   * ```ts\n   * katexOptions: {\n   *   displayMode: false,\n   *   throwOnError: false,\n   *   macros: {\n   *     '\\\\RR': '\\\\mathbb{R}',\n   *     '\\\\ZZ': '\\\\mathbb{Z}'\n   *   }\n   * }\n   * ```\n   */\n  katexOptions?: KatexOptions\n\n  /**\n   * Optional click handler for inline math nodes.\n   * Called when a user clicks on an inline math expression in the editor.\n   *\n   * @param node - The ProseMirror node representing the inline math element\n   * @param pos - The position of the node within the document\n   * @example\n   * ```ts\n   * onClick: (node, pos) => {\n   *   console.log('Inline math clicked:', node.attrs.latex, 'at position:', pos)\n   * }\n   * ```\n   */\n  onClick?: (node: PMNode, pos: number) => void\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    inlineMath: {\n      /**\n       * Insert a inline math node with LaTeX string.\n       * @param options - Options for inserting inline math.\n       * @returns ReturnType\n       */\n      insertInlineMath: (options: { latex: string; pos?: number }) => ReturnType\n\n      /**\n       * Delete an inline math node.\n       * @returns ReturnType\n       */\n      deleteInlineMath: (options?: { pos?: number }) => ReturnType\n\n      /**\n       * Update inline math node with optional LaTeX string.\n       * @param options - Options for updating inline math.\n       * @returns ReturnType\n       */\n      updateInlineMath: (options?: { latex?: string; pos?: number }) => ReturnType\n    }\n  }\n}\n\n/**\n * InlineMath is a Tiptap extension for rendering inline mathematical expressions using KaTeX.\n * It allows users to insert LaTeX formatted math expressions inline within text.\n * It supports rendering, input rules for LaTeX syntax, and click handling for interaction.\n *\n * @example\n * ```javascript\n * import { InlineMath } from '@tiptap/extension-mathematics'\n * import { Editor } from '@tiptap/core'\n *\n * const editor = new Editor({\n *   extensions: [\n *     InlineMath.configure({\n *       onClick: (node, pos) => {\n *         console.log('Inline math clicked:', node.attrs.latex, 'at position:', pos)\n *       },\n *     }),\n *   ],\n * })\n */\nexport const InlineMath = Node.create<InlineMathOptions>({\n  name: 'inlineMath',\n\n  group: 'inline',\n\n  inline: true,\n\n  atom: true,\n\n  addOptions() {\n    return {\n      onClick: undefined,\n      katexOptions: undefined,\n    }\n  },\n\n  addAttributes() {\n    return {\n      latex: {\n        default: '',\n        parseHTML: element => element.getAttribute('data-latex'),\n        renderHTML: attributes => {\n          return {\n            'data-latex': attributes.latex,\n          }\n        },\n      },\n    }\n  },\n\n  addCommands() {\n    return {\n      insertInlineMath:\n        options =>\n        ({ editor, tr }) => {\n          const latex = options.latex\n\n          const from = options?.pos ?? editor.state.selection.from\n\n          if (!latex) {\n            return false\n          }\n\n          tr.replaceWith(from, from, this.type.create({ latex }))\n          return true\n        },\n\n      deleteInlineMath:\n        options =>\n        ({ editor, tr }) => {\n          const pos = options?.pos ?? editor.state.selection.$from.pos\n          const node = editor.state.doc.nodeAt(pos)\n\n          if (!node || node.type.name !== this.name) {\n            return false\n          }\n\n          tr.delete(pos, pos + node.nodeSize)\n          return true\n        },\n\n      updateInlineMath:\n        options =>\n        ({ editor, tr }) => {\n          const latex = options?.latex\n          let pos = options?.pos\n\n          if (pos === undefined) {\n            pos = editor.state.selection.$from.pos\n          }\n\n          const node = editor.state.doc.nodeAt(pos)\n\n          if (!node || node.type.name !== this.name) {\n            return false\n          }\n\n          tr.setNodeMarkup(pos, this.type, { ...node.attrs, latex })\n\n          return true\n        },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'span[data-type=\"inline-math\"]',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['span', mergeAttributes(HTMLAttributes, { 'data-type': 'inline-math' })]\n  },\n\n  parseMarkdown: (token: any) => {\n    return {\n      type: 'inlineMath',\n      attrs: {\n        latex: token.latex,\n      },\n    }\n  },\n\n  renderMarkdown: node => {\n    const latex = node.attrs?.latex || ''\n\n    return `$${latex}$`\n  },\n\n  markdownTokenizer: {\n    name: 'inlineMath',\n    level: 'inline',\n    start: (src: string) => src.indexOf('$'),\n    tokenize: (src: string) => {\n      // Match $latex$ syntax for inline math (but not $$)\n      const match = src.match(/^\\$([^$]+)\\$(?!\\$)/)\n      if (!match) {\n        return undefined\n      }\n\n      const [fullMatch, latex] = match\n\n      return {\n        type: 'inlineMath',\n        raw: fullMatch,\n        latex: latex.trim(),\n      }\n    },\n  },\n\n  addInputRules() {\n    return [\n      new InputRule({\n        find: /(^|[^$])(\\$\\$([^$\\n]+?)\\$\\$)(?!\\$)/,\n        handler: ({ state, range, match }) => {\n          const latex = match[3]\n          const { tr } = state\n          const start = range.from\n          const end = range.to\n\n          tr.replaceWith(start, end, this.type.create({ latex }))\n        },\n      }),\n    ]\n  },\n\n  addNodeView() {\n    const { katexOptions } = this.options\n\n    return ({ node, getPos }) => {\n      const wrapper = document.createElement('span')\n      wrapper.className = 'tiptap-mathematics-render'\n\n      if (this.editor.isEditable) {\n        wrapper.classList.add('tiptap-mathematics-render--editable')\n      }\n\n      wrapper.dataset.type = 'inline-math'\n      wrapper.setAttribute('data-latex', node.attrs.latex)\n\n      function renderMath() {\n        try {\n          katex.render(node.attrs.latex, wrapper, katexOptions)\n          wrapper.classList.remove('inline-math-error')\n        } catch {\n          wrapper.textContent = node.attrs.latex\n          wrapper.classList.add('inline-math-error')\n        }\n      }\n\n      const handleClick = (event: MouseEvent) => {\n        event.preventDefault()\n        event.stopPropagation()\n        const pos = getPos()\n\n        if (pos == null) {\n          return\n        }\n\n        if (this.options.onClick) {\n          this.options.onClick(node, pos)\n        }\n      }\n\n      if (this.options.onClick) {\n        wrapper.addEventListener('click', handleClick)\n      }\n\n      renderMath()\n\n      return {\n        dom: wrapper,\n        destroy() {\n          wrapper.removeEventListener('click', handleClick)\n        },\n      }\n    }\n  },\n})\n", "import type { Editor } from '@tiptap/core'\nimport type { Transaction } from '@tiptap/pm/state'\n\n/**\n * Regular expression to match LaTeX math strings wrapped in single dollar signs.\n * This should not catch dollar signs which are not part of a math expression,\n * like those used for currency or other purposes.\n * It ensures that the dollar signs are not preceded or followed by digits,\n * allowing for proper identification of inline math expressions.\n *\n * - `$x^2 + y^2 = z^2$` will match\n * - `This is $inline math$ in text.` will match\n * - `This is $100$ dollars.` will not match (as it is not a math expression)\n * - `This is $x^2 + y^2 = z^2$ and $100$ dollars.` will match both math expressions\n */\nexport const mathMigrationRegex = /\\$(?!\\d+\\$)(.+?)\\$(?!\\d)/g\n\n/**\n * Creates a transaction that migrates existing math strings in the document to new math nodes.\n * This function traverses the document and replaces LaTeX math syntax (wrapped in single dollar signs)\n * with proper inline math nodes, preserving the mathematical content.\n *\n * @param editor - The editor instance containing the schema and configuration\n * @param tr - The transaction to modify with the migration operations\n * @returns The modified transaction with math string replacements\n *\n * @example\n * ```typescript\n * const editor = new Editor({ ... })\n * const tr = editor.state.tr\n * const updatedTr = createMathMigrateTransaction(editor, tr)\n * editor.view.dispatch(updatedTr)\n * ```\n */\nexport function createMathMigrateTransaction(editor: Editor, tr: Transaction, regex: RegExp = mathMigrationRegex) {\n  // we traverse the document and replace all math nodes with the new math nodes\n  tr.doc.descendants((node, pos) => {\n    if (!node.isText || !node.text || !node.text.includes('$')) {\n      return\n    }\n\n    const { text } = node\n\n    const match = node.text.match(regex)\n    if (!match) {\n      return\n    }\n\n    match.forEach(mathMatch => {\n      const start = text.indexOf(mathMatch)\n      const end = start + mathMatch.length\n\n      const from = tr.mapping.map(pos + start)\n\n      const $from = tr.doc.resolve(from)\n      const parent = $from.parent\n      const index = $from.index()\n\n      const { inlineMath } = editor.schema.nodes\n\n      if (!parent.canReplaceWith(index, index + 1, inlineMath)) {\n        return\n      }\n\n      // Replace the math syntax with a new math node\n      tr.replaceWith(\n        tr.mapping.map(pos + start),\n        tr.mapping.map(pos + end),\n        inlineMath.create({ latex: mathMatch.slice(1, -1) }),\n      )\n    })\n  })\n\n  // don't add to history\n  tr.setMeta('addToHistory', false)\n  return tr\n}\n\n/**\n * Migrates existing math strings in the editor document to math nodes.\n * This function creates and dispatches a transaction that converts LaTeX math syntax\n * (text wrapped in single dollar signs) into proper inline math nodes. The migration\n * happens immediately and is not added to the editor's history.\n *\n * @param editor - The editor instance to perform the migration on\n *\n * @example\n * ```typescript\n * const editor = new Editor({\n *   extensions: [Mathematics],\n *   content: 'This is inline math: $x^2 + y^2 = z^2$ in text.'\n * })\n *\n * // Math strings will be automatically migrated to math nodes\n * migrateMathStrings(editor)\n * ```\n */\nexport function migrateMathStrings(editor: Editor, regex: RegExp = mathMigrationRegex) {\n  const tr = createMathMigrateTransaction(editor, editor.state.tr, regex)\n  editor.view.dispatch(tr)\n}\n", "import { Mathematics } from './mathematics.js'\n\nexport * from './extensions/index.js'\nexport * from './mathematics.js'\nexport * from './types.js'\nexport * from './utils.js'\n\nexport default Mathematics\n"],
  "mappings": "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",
  "names": ["Node", "mergeAttributes", "InputRule", "katex"]
}
