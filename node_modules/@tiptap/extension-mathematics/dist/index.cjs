"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  BlockMath: () => BlockMath,
  InlineMath: () => InlineMath,
  Mathematics: () => Mathematics,
  createMathMigrateTransaction: () => createMathMigrateTransaction,
  default: () => index_default,
  mathMigrationRegex: () => mathMigrationRegex,
  migrateMathStrings: () => migrateMathStrings
});
module.exports = __toCommonJS(index_exports);

// src/mathematics.ts
var import_core3 = require("@tiptap/core");

// src/extensions/BlockMath.ts
var import_core = require("@tiptap/core");
var import_katex = __toESM(require("katex"), 1);
var BlockMath = import_core.Node.create({
  name: "blockMath",
  group: "block",
  atom: true,
  addOptions() {
    return {
      onClick: void 0,
      katexOptions: void 0
    };
  },
  addAttributes() {
    return {
      latex: {
        default: "",
        parseHTML: (element) => element.getAttribute("data-latex"),
        renderHTML: (attributes) => {
          return {
            "data-latex": attributes.latex
          };
        }
      }
    };
  },
  addCommands() {
    return {
      insertBlockMath: (options) => ({ commands, editor }) => {
        const { latex, pos } = options;
        if (!latex) {
          return false;
        }
        return commands.insertContentAt(pos != null ? pos : editor.state.selection.from, {
          type: this.name,
          attrs: { latex }
        });
      },
      deleteBlockMath: (options) => ({ editor, tr }) => {
        var _a;
        const pos = (_a = options == null ? void 0 : options.pos) != null ? _a : editor.state.selection.$from.pos;
        const node = editor.state.doc.nodeAt(pos);
        if (!node || node.type.name !== this.name) {
          return false;
        }
        tr.delete(pos, pos + node.nodeSize);
        return true;
      },
      updateBlockMath: (options) => ({ editor, tr }) => {
        const latex = options == null ? void 0 : options.latex;
        let pos = options == null ? void 0 : options.pos;
        if (pos === void 0) {
          pos = editor.state.selection.$from.pos;
        }
        const node = editor.state.doc.nodeAt(pos);
        if (!node || node.type.name !== this.name) {
          return false;
        }
        tr.setNodeMarkup(pos, this.type, {
          ...node.attrs,
          latex: latex || node.attrs.latex
        });
        return true;
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: 'div[data-type="block-math"]'
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["div", (0, import_core.mergeAttributes)(HTMLAttributes, { "data-type": "block-math" })];
  },
  parseMarkdown: (token) => {
    return {
      type: "blockMath",
      attrs: {
        latex: token.latex
      }
    };
  },
  renderMarkdown: (node) => {
    var _a;
    const latex = ((_a = node.attrs) == null ? void 0 : _a.latex) || "";
    const output = ["$$", latex, "$$"];
    return output.join("\n");
  },
  markdownTokenizer: {
    name: "blockMath",
    level: "block",
    start: (src) => src.indexOf("$$"),
    tokenize: (src) => {
      const match = src.match(/^\$\$([^$]+)\$\$/);
      if (!match) {
        return void 0;
      }
      const [fullMatch, latex] = match;
      return {
        type: "blockMath",
        raw: fullMatch,
        latex: latex.trim()
      };
    }
  },
  addInputRules() {
    return [
      new import_core.InputRule({
        find: /^\$\$\$([^$]+)\$\$\$$/,
        handler: ({ state, range, match }) => {
          const [, latex] = match;
          const { tr } = state;
          const start = range.from;
          const end = range.to;
          tr.replaceWith(start, end, this.type.create({ latex }));
        }
      })
    ];
  },
  addNodeView() {
    const { katexOptions } = this.options;
    return ({ node, getPos }) => {
      const wrapper = document.createElement("div");
      const innerWrapper = document.createElement("div");
      wrapper.className = "tiptap-mathematics-render";
      if (this.editor.isEditable) {
        wrapper.classList.add("tiptap-mathematics-render--editable");
      }
      innerWrapper.className = "block-math-inner";
      wrapper.dataset.type = "block-math";
      wrapper.setAttribute("data-latex", node.attrs.latex);
      wrapper.appendChild(innerWrapper);
      function renderMath() {
        try {
          import_katex.default.render(node.attrs.latex, innerWrapper, katexOptions);
          wrapper.classList.remove("block-math-error");
        } catch {
          wrapper.textContent = node.attrs.latex;
          wrapper.classList.add("block-math-error");
        }
      }
      const handleClick = (event) => {
        event.preventDefault();
        event.stopPropagation();
        const pos = getPos();
        if (pos == null) {
          return;
        }
        if (this.options.onClick) {
          this.options.onClick(node, pos);
        }
      };
      if (this.options.onClick) {
        wrapper.addEventListener("click", handleClick);
      }
      renderMath();
      return {
        dom: wrapper,
        destroy() {
          wrapper.removeEventListener("click", handleClick);
        }
      };
    };
  }
});

// src/extensions/InlineMath.ts
var import_core2 = require("@tiptap/core");
var import_katex2 = __toESM(require("katex"), 1);
var InlineMath = import_core2.Node.create({
  name: "inlineMath",
  group: "inline",
  inline: true,
  atom: true,
  addOptions() {
    return {
      onClick: void 0,
      katexOptions: void 0
    };
  },
  addAttributes() {
    return {
      latex: {
        default: "",
        parseHTML: (element) => element.getAttribute("data-latex"),
        renderHTML: (attributes) => {
          return {
            "data-latex": attributes.latex
          };
        }
      }
    };
  },
  addCommands() {
    return {
      insertInlineMath: (options) => ({ editor, tr }) => {
        var _a;
        const latex = options.latex;
        const from = (_a = options == null ? void 0 : options.pos) != null ? _a : editor.state.selection.from;
        if (!latex) {
          return false;
        }
        tr.replaceWith(from, from, this.type.create({ latex }));
        return true;
      },
      deleteInlineMath: (options) => ({ editor, tr }) => {
        var _a;
        const pos = (_a = options == null ? void 0 : options.pos) != null ? _a : editor.state.selection.$from.pos;
        const node = editor.state.doc.nodeAt(pos);
        if (!node || node.type.name !== this.name) {
          return false;
        }
        tr.delete(pos, pos + node.nodeSize);
        return true;
      },
      updateInlineMath: (options) => ({ editor, tr }) => {
        const latex = options == null ? void 0 : options.latex;
        let pos = options == null ? void 0 : options.pos;
        if (pos === void 0) {
          pos = editor.state.selection.$from.pos;
        }
        const node = editor.state.doc.nodeAt(pos);
        if (!node || node.type.name !== this.name) {
          return false;
        }
        tr.setNodeMarkup(pos, this.type, { ...node.attrs, latex });
        return true;
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: 'span[data-type="inline-math"]'
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["span", (0, import_core2.mergeAttributes)(HTMLAttributes, { "data-type": "inline-math" })];
  },
  parseMarkdown: (token) => {
    return {
      type: "inlineMath",
      attrs: {
        latex: token.latex
      }
    };
  },
  renderMarkdown: (node) => {
    var _a;
    const latex = ((_a = node.attrs) == null ? void 0 : _a.latex) || "";
    return `$${latex}$`;
  },
  markdownTokenizer: {
    name: "inlineMath",
    level: "inline",
    start: (src) => src.indexOf("$"),
    tokenize: (src) => {
      const match = src.match(/^\$([^$]+)\$(?!\$)/);
      if (!match) {
        return void 0;
      }
      const [fullMatch, latex] = match;
      return {
        type: "inlineMath",
        raw: fullMatch,
        latex: latex.trim()
      };
    }
  },
  addInputRules() {
    return [
      new import_core2.InputRule({
        find: /(^|[^$])(\$\$([^$\n]+?)\$\$)(?!\$)/,
        handler: ({ state, range, match }) => {
          const latex = match[3];
          const { tr } = state;
          const start = range.from;
          const end = range.to;
          tr.replaceWith(start, end, this.type.create({ latex }));
        }
      })
    ];
  },
  addNodeView() {
    const { katexOptions } = this.options;
    return ({ node, getPos }) => {
      const wrapper = document.createElement("span");
      wrapper.className = "tiptap-mathematics-render";
      if (this.editor.isEditable) {
        wrapper.classList.add("tiptap-mathematics-render--editable");
      }
      wrapper.dataset.type = "inline-math";
      wrapper.setAttribute("data-latex", node.attrs.latex);
      function renderMath() {
        try {
          import_katex2.default.render(node.attrs.latex, wrapper, katexOptions);
          wrapper.classList.remove("inline-math-error");
        } catch {
          wrapper.textContent = node.attrs.latex;
          wrapper.classList.add("inline-math-error");
        }
      }
      const handleClick = (event) => {
        event.preventDefault();
        event.stopPropagation();
        const pos = getPos();
        if (pos == null) {
          return;
        }
        if (this.options.onClick) {
          this.options.onClick(node, pos);
        }
      };
      if (this.options.onClick) {
        wrapper.addEventListener("click", handleClick);
      }
      renderMath();
      return {
        dom: wrapper,
        destroy() {
          wrapper.removeEventListener("click", handleClick);
        }
      };
    };
  }
});

// src/mathematics.ts
var Mathematics = import_core3.Extension.create({
  name: "Mathematics",
  addOptions() {
    return {
      inlineOptions: void 0,
      blockOptions: void 0,
      katexOptions: void 0
    };
  },
  addExtensions() {
    return [
      BlockMath.configure({ ...this.options.blockOptions, katexOptions: this.options.katexOptions }),
      InlineMath.configure({ ...this.options.inlineOptions, katexOptions: this.options.katexOptions })
    ];
  }
});

// src/utils.ts
var mathMigrationRegex = /\$(?!\d+\$)(.+?)\$(?!\d)/g;
function createMathMigrateTransaction(editor, tr, regex = mathMigrationRegex) {
  tr.doc.descendants((node, pos) => {
    if (!node.isText || !node.text || !node.text.includes("$")) {
      return;
    }
    const { text } = node;
    const match = node.text.match(regex);
    if (!match) {
      return;
    }
    match.forEach((mathMatch) => {
      const start = text.indexOf(mathMatch);
      const end = start + mathMatch.length;
      const from = tr.mapping.map(pos + start);
      const $from = tr.doc.resolve(from);
      const parent = $from.parent;
      const index = $from.index();
      const { inlineMath } = editor.schema.nodes;
      if (!parent.canReplaceWith(index, index + 1, inlineMath)) {
        return;
      }
      tr.replaceWith(
        tr.mapping.map(pos + start),
        tr.mapping.map(pos + end),
        inlineMath.create({ latex: mathMatch.slice(1, -1) })
      );
    });
  });
  tr.setMeta("addToHistory", false);
  return tr;
}
function migrateMathStrings(editor, regex = mathMigrationRegex) {
  const tr = createMathMigrateTransaction(editor, editor.state.tr, regex);
  editor.view.dispatch(tr);
}

// src/index.ts
var index_default = Mathematics;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BlockMath,
  InlineMath,
  Mathematics,
  createMathMigrateTransaction,
  mathMigrationRegex,
  migrateMathStrings
});
//# sourceMappingURL=index.cjs.map