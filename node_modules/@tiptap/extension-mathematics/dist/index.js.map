{"version":3,"sources":["../src/mathematics.ts","../src/extensions/BlockMath.ts","../src/extensions/InlineMath.ts","../src/utils.ts","../src/index.ts"],"sourcesContent":["import { Extension } from '@tiptap/core'\n\nimport { BlockMath, InlineMath } from './extensions/index.js'\nimport type { MathematicsOptions } from './types.js'\n\n/**\n * Mathematics extension for Tiptap that provides both inline and block math support using KaTeX.\n * This extension combines the InlineMath and BlockMath extensions to provide a complete\n * mathematical expression solution for rich text editing. It supports LaTeX syntax,\n * custom rendering options, and interactive math nodes.\n *\n * @example\n * ```typescript\n * import { Editor } from '@tiptap/core'\n * import { Mathematics } from '@tiptap/extension-mathematics'\n * import { migrateMathStrings } from '@tiptap/extension-mathematics/utils'\n *\n * const editor = new Editor({\n *   extensions: [\n *     Mathematics.configure({\n *       inlineOptions: {\n *         onClick: (node, pos) => {\n *           console.log('Inline math clicked:', node.attrs.latex)\n *         }\n *       },\n *       blockOptions: {\n *         onClick: (node, pos) => {\n *           console.log('Block math clicked:', node.attrs.latex)\n *         }\n *       },\n *       katexOptions: {\n *         displayMode: false,\n *         throwOnError: false,\n *         macros: {\n *           '\\\\RR': '\\\\mathbb{R}',\n *           '\\\\ZZ': '\\\\mathbb{Z}'\n *         }\n *       }\n *     })\n *   ],\n *   content: `\n *     <p>Inline math: $E = mc^2$</p>\n *     <div data-type=\"block-math\" data-latex=\"\\\\sum_{i=1}^{n} x_i = X\"></div>\n *   `,\n *   onCreate({ editor }) {\n *     // Optional: Migrate existing math strings to math nodes\n *     migrateMathStrings(editor)\n *   }\n * })\n * ```\n */\nexport const Mathematics = Extension.create<MathematicsOptions>({\n  name: 'Mathematics',\n\n  addOptions() {\n    return {\n      inlineOptions: undefined,\n      blockOptions: undefined,\n      katexOptions: undefined,\n    }\n  },\n\n  addExtensions() {\n    return [\n      BlockMath.configure({ ...this.options.blockOptions, katexOptions: this.options.katexOptions }),\n      InlineMath.configure({ ...this.options.inlineOptions, katexOptions: this.options.katexOptions }),\n    ]\n  },\n})\n\nexport default Mathematics\n","import { InputRule, mergeAttributes, Node } from '@tiptap/core'\nimport type { Node as PMNode } from '@tiptap/pm/model'\nimport katex, { type KatexOptions } from 'katex'\n\n/**\n * Configuration options for the BlockMath extension.\n */\nexport type BlockMathOptions = {\n  /**\n   * KaTeX specific options\n   * @see https://katex.org/docs/options.html\n   * @example\n   * ```ts\n   * katexOptions: {\n   *   displayMode: true,\n   *   throwOnError: false,\n   * },\n   */\n  katexOptions?: KatexOptions\n\n  /**\n   * Optional click handler for block math nodes.\n   * Called when a user clicks on a block math expression in the editor.\n   *\n   * @param node - The ProseMirror node representing the block math element\n   * @param pos - The position of the node within the document\n   * @example\n   * ```ts\n   * onClick: (node, pos) => {\n   *   console.log('Block math clicked:', node.attrs.latex, 'at position:', pos)\n   * },\n   * ```\n   */\n  onClick?: (node: PMNode, pos: number) => void\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    insertBlockMath: {\n      /**\n       * Inserts a math block node with LaTeX string.\n       * @param options - Options for inserting block math.\n       * @returns ReturnType\n       */\n      insertBlockMath: (options: { latex: string; pos?: number }) => ReturnType\n\n      /**\n       * Deletes a block math node.\n       * @returns ReturnType\n       */\n      deleteBlockMath: (options?: { pos?: number }) => ReturnType\n\n      /**\n       * Update block math node with optional LaTeX string.\n       * @param options - Options for updating block math.\n       * @returns ReturnType\n       */\n      updateBlockMath: (options?: { latex: string; pos?: number }) => ReturnType\n    }\n  }\n}\n\n/**\n * BlockMath is a Tiptap extension for rendering block mathematical expressions using KaTeX.\n * It allows users to insert LaTeX formatted math expressions block within text.\n * It supports rendering, input rules for LaTeX syntax, and click handling for interaction.\n *\n * @example\n * ```javascript\n * import { BlockMath } from '@tiptap/extension-mathematics'\n * import { Editor } from '@tiptap/core'\n *\n * const editor = new Editor({\n *   extensions: [\n *     BlockMath.configure({\n *       onClick: (node, pos) => {\n *         console.log('Block math clicked:', node.attrs.latex, 'at position:', pos)\n *       },\n *     }),\n *   ],\n * })\n */\nexport const BlockMath = Node.create<BlockMathOptions>({\n  name: 'blockMath',\n\n  group: 'block',\n\n  atom: true,\n\n  addOptions() {\n    return {\n      onClick: undefined,\n      katexOptions: undefined,\n    }\n  },\n\n  addAttributes() {\n    return {\n      latex: {\n        default: '',\n        parseHTML: element => element.getAttribute('data-latex'),\n        renderHTML: attributes => {\n          return {\n            'data-latex': attributes.latex,\n          }\n        },\n      },\n    }\n  },\n\n  addCommands() {\n    return {\n      insertBlockMath:\n        options =>\n        ({ commands, editor }) => {\n          const { latex, pos } = options\n\n          if (!latex) {\n            return false\n          }\n\n          return commands.insertContentAt(pos ?? editor.state.selection.from, {\n            type: this.name,\n            attrs: { latex },\n          })\n        },\n\n      deleteBlockMath:\n        options =>\n        ({ editor, tr }) => {\n          const pos = options?.pos ?? editor.state.selection.$from.pos\n          const node = editor.state.doc.nodeAt(pos)\n\n          if (!node || node.type.name !== this.name) {\n            return false\n          }\n\n          tr.delete(pos, pos + node.nodeSize)\n          return true\n        },\n\n      updateBlockMath:\n        options =>\n        ({ editor, tr }) => {\n          const latex = options?.latex\n          let pos = options?.pos\n\n          if (pos === undefined) {\n            pos = editor.state.selection.$from.pos\n          }\n\n          const node = editor.state.doc.nodeAt(pos)\n\n          if (!node || node.type.name !== this.name) {\n            return false\n          }\n\n          tr.setNodeMarkup(pos, this.type, {\n            ...node.attrs,\n            latex: latex || node.attrs.latex,\n          })\n\n          return true\n        },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'div[data-type=\"block-math\"]',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['div', mergeAttributes(HTMLAttributes, { 'data-type': 'block-math' })]\n  },\n\n  parseMarkdown: (token: any) => {\n    return {\n      type: 'blockMath',\n      attrs: {\n        latex: token.latex,\n      },\n    }\n  },\n\n  renderMarkdown: node => {\n    const latex = node.attrs?.latex || ''\n\n    const output = ['$$', latex, '$$']\n    return output.join('\\n')\n  },\n\n  markdownTokenizer: {\n    name: 'blockMath',\n    level: 'block',\n    start: (src: string) => src.indexOf('$$'),\n    tokenize: (src: string) => {\n      // Match $$latex$$ syntax for block math\n      const match = src.match(/^\\$\\$([^$]+)\\$\\$/)\n      if (!match) {\n        return undefined\n      }\n\n      const [fullMatch, latex] = match\n\n      return {\n        type: 'blockMath',\n        raw: fullMatch,\n        latex: latex.trim(),\n      }\n    },\n  },\n\n  addInputRules() {\n    return [\n      new InputRule({\n        find: /^\\$\\$\\$([^$]+)\\$\\$\\$$/,\n        handler: ({ state, range, match }) => {\n          const [, latex] = match\n          const { tr } = state\n          const start = range.from\n          const end = range.to\n\n          tr.replaceWith(start, end, this.type.create({ latex }))\n        },\n      }),\n    ]\n  },\n\n  addNodeView() {\n    const { katexOptions } = this.options\n\n    return ({ node, getPos }) => {\n      const wrapper = document.createElement('div')\n      const innerWrapper = document.createElement('div')\n      wrapper.className = 'tiptap-mathematics-render'\n\n      if (this.editor.isEditable) {\n        wrapper.classList.add('tiptap-mathematics-render--editable')\n      }\n\n      innerWrapper.className = 'block-math-inner'\n      wrapper.dataset.type = 'block-math'\n      wrapper.setAttribute('data-latex', node.attrs.latex)\n      wrapper.appendChild(innerWrapper)\n\n      function renderMath() {\n        try {\n          katex.render(node.attrs.latex, innerWrapper, katexOptions)\n          wrapper.classList.remove('block-math-error')\n        } catch {\n          wrapper.textContent = node.attrs.latex\n          wrapper.classList.add('block-math-error')\n        }\n      }\n\n      const handleClick = (event: MouseEvent) => {\n        event.preventDefault()\n        event.stopPropagation()\n        const pos = getPos()\n\n        if (pos == null) {\n          return\n        }\n\n        if (this.options.onClick) {\n          this.options.onClick(node, pos)\n        }\n      }\n\n      if (this.options.onClick) {\n        wrapper.addEventListener('click', handleClick)\n      }\n\n      renderMath()\n\n      return {\n        dom: wrapper,\n        destroy() {\n          wrapper.removeEventListener('click', handleClick)\n        },\n      }\n    }\n  },\n})\n","import { InputRule, mergeAttributes, Node } from '@tiptap/core'\nimport type { Node as PMNode } from '@tiptap/pm/model'\nimport katex, { type KatexOptions } from 'katex'\n\n/**\n * Configuration options for the InlineMath extension.\n */\nexport type InlineMathOptions = {\n  /**\n   * KaTeX specific options\n   * @see https://katex.org/docs/options.html\n   * @example\n   * ```ts\n   * katexOptions: {\n   *   displayMode: false,\n   *   throwOnError: false,\n   *   macros: {\n   *     '\\\\RR': '\\\\mathbb{R}',\n   *     '\\\\ZZ': '\\\\mathbb{Z}'\n   *   }\n   * }\n   * ```\n   */\n  katexOptions?: KatexOptions\n\n  /**\n   * Optional click handler for inline math nodes.\n   * Called when a user clicks on an inline math expression in the editor.\n   *\n   * @param node - The ProseMirror node representing the inline math element\n   * @param pos - The position of the node within the document\n   * @example\n   * ```ts\n   * onClick: (node, pos) => {\n   *   console.log('Inline math clicked:', node.attrs.latex, 'at position:', pos)\n   * }\n   * ```\n   */\n  onClick?: (node: PMNode, pos: number) => void\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    inlineMath: {\n      /**\n       * Insert a inline math node with LaTeX string.\n       * @param options - Options for inserting inline math.\n       * @returns ReturnType\n       */\n      insertInlineMath: (options: { latex: string; pos?: number }) => ReturnType\n\n      /**\n       * Delete an inline math node.\n       * @returns ReturnType\n       */\n      deleteInlineMath: (options?: { pos?: number }) => ReturnType\n\n      /**\n       * Update inline math node with optional LaTeX string.\n       * @param options - Options for updating inline math.\n       * @returns ReturnType\n       */\n      updateInlineMath: (options?: { latex?: string; pos?: number }) => ReturnType\n    }\n  }\n}\n\n/**\n * InlineMath is a Tiptap extension for rendering inline mathematical expressions using KaTeX.\n * It allows users to insert LaTeX formatted math expressions inline within text.\n * It supports rendering, input rules for LaTeX syntax, and click handling for interaction.\n *\n * @example\n * ```javascript\n * import { InlineMath } from '@tiptap/extension-mathematics'\n * import { Editor } from '@tiptap/core'\n *\n * const editor = new Editor({\n *   extensions: [\n *     InlineMath.configure({\n *       onClick: (node, pos) => {\n *         console.log('Inline math clicked:', node.attrs.latex, 'at position:', pos)\n *       },\n *     }),\n *   ],\n * })\n */\nexport const InlineMath = Node.create<InlineMathOptions>({\n  name: 'inlineMath',\n\n  group: 'inline',\n\n  inline: true,\n\n  atom: true,\n\n  addOptions() {\n    return {\n      onClick: undefined,\n      katexOptions: undefined,\n    }\n  },\n\n  addAttributes() {\n    return {\n      latex: {\n        default: '',\n        parseHTML: element => element.getAttribute('data-latex'),\n        renderHTML: attributes => {\n          return {\n            'data-latex': attributes.latex,\n          }\n        },\n      },\n    }\n  },\n\n  addCommands() {\n    return {\n      insertInlineMath:\n        options =>\n        ({ editor, tr }) => {\n          const latex = options.latex\n\n          const from = options?.pos ?? editor.state.selection.from\n\n          if (!latex) {\n            return false\n          }\n\n          tr.replaceWith(from, from, this.type.create({ latex }))\n          return true\n        },\n\n      deleteInlineMath:\n        options =>\n        ({ editor, tr }) => {\n          const pos = options?.pos ?? editor.state.selection.$from.pos\n          const node = editor.state.doc.nodeAt(pos)\n\n          if (!node || node.type.name !== this.name) {\n            return false\n          }\n\n          tr.delete(pos, pos + node.nodeSize)\n          return true\n        },\n\n      updateInlineMath:\n        options =>\n        ({ editor, tr }) => {\n          const latex = options?.latex\n          let pos = options?.pos\n\n          if (pos === undefined) {\n            pos = editor.state.selection.$from.pos\n          }\n\n          const node = editor.state.doc.nodeAt(pos)\n\n          if (!node || node.type.name !== this.name) {\n            return false\n          }\n\n          tr.setNodeMarkup(pos, this.type, { ...node.attrs, latex })\n\n          return true\n        },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'span[data-type=\"inline-math\"]',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['span', mergeAttributes(HTMLAttributes, { 'data-type': 'inline-math' })]\n  },\n\n  parseMarkdown: (token: any) => {\n    return {\n      type: 'inlineMath',\n      attrs: {\n        latex: token.latex,\n      },\n    }\n  },\n\n  renderMarkdown: node => {\n    const latex = node.attrs?.latex || ''\n\n    return `$${latex}$`\n  },\n\n  markdownTokenizer: {\n    name: 'inlineMath',\n    level: 'inline',\n    start: (src: string) => src.indexOf('$'),\n    tokenize: (src: string) => {\n      // Match $latex$ syntax for inline math (but not $$)\n      const match = src.match(/^\\$([^$]+)\\$(?!\\$)/)\n      if (!match) {\n        return undefined\n      }\n\n      const [fullMatch, latex] = match\n\n      return {\n        type: 'inlineMath',\n        raw: fullMatch,\n        latex: latex.trim(),\n      }\n    },\n  },\n\n  addInputRules() {\n    return [\n      new InputRule({\n        find: /(^|[^$])(\\$\\$([^$\\n]+?)\\$\\$)(?!\\$)/,\n        handler: ({ state, range, match }) => {\n          const latex = match[3]\n          const { tr } = state\n          const start = range.from\n          const end = range.to\n\n          tr.replaceWith(start, end, this.type.create({ latex }))\n        },\n      }),\n    ]\n  },\n\n  addNodeView() {\n    const { katexOptions } = this.options\n\n    return ({ node, getPos }) => {\n      const wrapper = document.createElement('span')\n      wrapper.className = 'tiptap-mathematics-render'\n\n      if (this.editor.isEditable) {\n        wrapper.classList.add('tiptap-mathematics-render--editable')\n      }\n\n      wrapper.dataset.type = 'inline-math'\n      wrapper.setAttribute('data-latex', node.attrs.latex)\n\n      function renderMath() {\n        try {\n          katex.render(node.attrs.latex, wrapper, katexOptions)\n          wrapper.classList.remove('inline-math-error')\n        } catch {\n          wrapper.textContent = node.attrs.latex\n          wrapper.classList.add('inline-math-error')\n        }\n      }\n\n      const handleClick = (event: MouseEvent) => {\n        event.preventDefault()\n        event.stopPropagation()\n        const pos = getPos()\n\n        if (pos == null) {\n          return\n        }\n\n        if (this.options.onClick) {\n          this.options.onClick(node, pos)\n        }\n      }\n\n      if (this.options.onClick) {\n        wrapper.addEventListener('click', handleClick)\n      }\n\n      renderMath()\n\n      return {\n        dom: wrapper,\n        destroy() {\n          wrapper.removeEventListener('click', handleClick)\n        },\n      }\n    }\n  },\n})\n","import type { Editor } from '@tiptap/core'\nimport type { Transaction } from '@tiptap/pm/state'\n\n/**\n * Regular expression to match LaTeX math strings wrapped in single dollar signs.\n * This should not catch dollar signs which are not part of a math expression,\n * like those used for currency or other purposes.\n * It ensures that the dollar signs are not preceded or followed by digits,\n * allowing for proper identification of inline math expressions.\n *\n * - `$x^2 + y^2 = z^2$` will match\n * - `This is $inline math$ in text.` will match\n * - `This is $100$ dollars.` will not match (as it is not a math expression)\n * - `This is $x^2 + y^2 = z^2$ and $100$ dollars.` will match both math expressions\n */\nexport const mathMigrationRegex = /\\$(?!\\d+\\$)(.+?)\\$(?!\\d)/g\n\n/**\n * Creates a transaction that migrates existing math strings in the document to new math nodes.\n * This function traverses the document and replaces LaTeX math syntax (wrapped in single dollar signs)\n * with proper inline math nodes, preserving the mathematical content.\n *\n * @param editor - The editor instance containing the schema and configuration\n * @param tr - The transaction to modify with the migration operations\n * @returns The modified transaction with math string replacements\n *\n * @example\n * ```typescript\n * const editor = new Editor({ ... })\n * const tr = editor.state.tr\n * const updatedTr = createMathMigrateTransaction(editor, tr)\n * editor.view.dispatch(updatedTr)\n * ```\n */\nexport function createMathMigrateTransaction(editor: Editor, tr: Transaction, regex: RegExp = mathMigrationRegex) {\n  // we traverse the document and replace all math nodes with the new math nodes\n  tr.doc.descendants((node, pos) => {\n    if (!node.isText || !node.text || !node.text.includes('$')) {\n      return\n    }\n\n    const { text } = node\n\n    const match = node.text.match(regex)\n    if (!match) {\n      return\n    }\n\n    match.forEach(mathMatch => {\n      const start = text.indexOf(mathMatch)\n      const end = start + mathMatch.length\n\n      const from = tr.mapping.map(pos + start)\n\n      const $from = tr.doc.resolve(from)\n      const parent = $from.parent\n      const index = $from.index()\n\n      const { inlineMath } = editor.schema.nodes\n\n      if (!parent.canReplaceWith(index, index + 1, inlineMath)) {\n        return\n      }\n\n      // Replace the math syntax with a new math node\n      tr.replaceWith(\n        tr.mapping.map(pos + start),\n        tr.mapping.map(pos + end),\n        inlineMath.create({ latex: mathMatch.slice(1, -1) }),\n      )\n    })\n  })\n\n  // don't add to history\n  tr.setMeta('addToHistory', false)\n  return tr\n}\n\n/**\n * Migrates existing math strings in the editor document to math nodes.\n * This function creates and dispatches a transaction that converts LaTeX math syntax\n * (text wrapped in single dollar signs) into proper inline math nodes. The migration\n * happens immediately and is not added to the editor's history.\n *\n * @param editor - The editor instance to perform the migration on\n *\n * @example\n * ```typescript\n * const editor = new Editor({\n *   extensions: [Mathematics],\n *   content: 'This is inline math: $x^2 + y^2 = z^2$ in text.'\n * })\n *\n * // Math strings will be automatically migrated to math nodes\n * migrateMathStrings(editor)\n * ```\n */\nexport function migrateMathStrings(editor: Editor, regex: RegExp = mathMigrationRegex) {\n  const tr = createMathMigrateTransaction(editor, editor.state.tr, regex)\n  editor.view.dispatch(tr)\n}\n","import { Mathematics } from './mathematics.js'\n\nexport * from './extensions/index.js'\nexport * from './mathematics.js'\nexport * from './types.js'\nexport * from './utils.js'\n\nexport default Mathematics\n"],"mappings":";AAAA,SAAS,iBAAiB;;;ACA1B,SAAS,WAAW,iBAAiB,YAAY;AAEjD,OAAO,WAAkC;AAgFlC,IAAM,YAAY,KAAK,OAAyB;AAAA,EACrD,MAAM;AAAA,EAEN,OAAO;AAAA,EAEP,MAAM;AAAA,EAEN,aAAa;AACX,WAAO;AAAA,MACL,SAAS;AAAA,MACT,cAAc;AAAA,IAChB;AAAA,EACF;AAAA,EAEA,gBAAgB;AACd,WAAO;AAAA,MACL,OAAO;AAAA,QACL,SAAS;AAAA,QACT,WAAW,aAAW,QAAQ,aAAa,YAAY;AAAA,QACvD,YAAY,gBAAc;AACxB,iBAAO;AAAA,YACL,cAAc,WAAW;AAAA,UAC3B;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EAEA,cAAc;AACZ,WAAO;AAAA,MACL,iBACE,aACA,CAAC,EAAE,UAAU,OAAO,MAAM;AACxB,cAAM,EAAE,OAAO,IAAI,IAAI;AAEvB,YAAI,CAAC,OAAO;AACV,iBAAO;AAAA,QACT;AAEA,eAAO,SAAS,gBAAgB,oBAAO,OAAO,MAAM,UAAU,MAAM;AAAA,UAClE,MAAM,KAAK;AAAA,UACX,OAAO,EAAE,MAAM;AAAA,QACjB,CAAC;AAAA,MACH;AAAA,MAEF,iBACE,aACA,CAAC,EAAE,QAAQ,GAAG,MAAM;AAjI5B;AAkIU,cAAM,OAAM,wCAAS,QAAT,YAAgB,OAAO,MAAM,UAAU,MAAM;AACzD,cAAM,OAAO,OAAO,MAAM,IAAI,OAAO,GAAG;AAExC,YAAI,CAAC,QAAQ,KAAK,KAAK,SAAS,KAAK,MAAM;AACzC,iBAAO;AAAA,QACT;AAEA,WAAG,OAAO,KAAK,MAAM,KAAK,QAAQ;AAClC,eAAO;AAAA,MACT;AAAA,MAEF,iBACE,aACA,CAAC,EAAE,QAAQ,GAAG,MAAM;AAClB,cAAM,QAAQ,mCAAS;AACvB,YAAI,MAAM,mCAAS;AAEnB,YAAI,QAAQ,QAAW;AACrB,gBAAM,OAAO,MAAM,UAAU,MAAM;AAAA,QACrC;AAEA,cAAM,OAAO,OAAO,MAAM,IAAI,OAAO,GAAG;AAExC,YAAI,CAAC,QAAQ,KAAK,KAAK,SAAS,KAAK,MAAM;AACzC,iBAAO;AAAA,QACT;AAEA,WAAG,cAAc,KAAK,KAAK,MAAM;AAAA,UAC/B,GAAG,KAAK;AAAA,UACR,OAAO,SAAS,KAAK,MAAM;AAAA,QAC7B,CAAC;AAED,eAAO;AAAA,MACT;AAAA,IACJ;AAAA,EACF;AAAA,EAEA,YAAY;AACV,WAAO;AAAA,MACL;AAAA,QACE,KAAK;AAAA,MACP;AAAA,IACF;AAAA,EACF;AAAA,EAEA,WAAW,EAAE,eAAe,GAAG;AAC7B,WAAO,CAAC,OAAO,gBAAgB,gBAAgB,EAAE,aAAa,aAAa,CAAC,CAAC;AAAA,EAC/E;AAAA,EAEA,eAAe,CAAC,UAAe;AAC7B,WAAO;AAAA,MACL,MAAM;AAAA,MACN,OAAO;AAAA,QACL,OAAO,MAAM;AAAA,MACf;AAAA,IACF;AAAA,EACF;AAAA,EAEA,gBAAgB,UAAQ;AA5L1B;AA6LI,UAAM,UAAQ,UAAK,UAAL,mBAAY,UAAS;AAEnC,UAAM,SAAS,CAAC,MAAM,OAAO,IAAI;AACjC,WAAO,OAAO,KAAK,IAAI;AAAA,EACzB;AAAA,EAEA,mBAAmB;AAAA,IACjB,MAAM;AAAA,IACN,OAAO;AAAA,IACP,OAAO,CAAC,QAAgB,IAAI,QAAQ,IAAI;AAAA,IACxC,UAAU,CAAC,QAAgB;AAEzB,YAAM,QAAQ,IAAI,MAAM,kBAAkB;AAC1C,UAAI,CAAC,OAAO;AACV,eAAO;AAAA,MACT;AAEA,YAAM,CAAC,WAAW,KAAK,IAAI;AAE3B,aAAO;AAAA,QACL,MAAM;AAAA,QACN,KAAK;AAAA,QACL,OAAO,MAAM,KAAK;AAAA,MACpB;AAAA,IACF;AAAA,EACF;AAAA,EAEA,gBAAgB;AACd,WAAO;AAAA,MACL,IAAI,UAAU;AAAA,QACZ,MAAM;AAAA,QACN,SAAS,CAAC,EAAE,OAAO,OAAO,MAAM,MAAM;AACpC,gBAAM,CAAC,EAAE,KAAK,IAAI;AAClB,gBAAM,EAAE,GAAG,IAAI;AACf,gBAAM,QAAQ,MAAM;AACpB,gBAAM,MAAM,MAAM;AAElB,aAAG,YAAY,OAAO,KAAK,KAAK,KAAK,OAAO,EAAE,MAAM,CAAC,CAAC;AAAA,QACxD;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EAEA,cAAc;AACZ,UAAM,EAAE,aAAa,IAAI,KAAK;AAE9B,WAAO,CAAC,EAAE,MAAM,OAAO,MAAM;AAC3B,YAAM,UAAU,SAAS,cAAc,KAAK;AAC5C,YAAM,eAAe,SAAS,cAAc,KAAK;AACjD,cAAQ,YAAY;AAEpB,UAAI,KAAK,OAAO,YAAY;AAC1B,gBAAQ,UAAU,IAAI,qCAAqC;AAAA,MAC7D;AAEA,mBAAa,YAAY;AACzB,cAAQ,QAAQ,OAAO;AACvB,cAAQ,aAAa,cAAc,KAAK,MAAM,KAAK;AACnD,cAAQ,YAAY,YAAY;AAEhC,eAAS,aAAa;AACpB,YAAI;AACF,gBAAM,OAAO,KAAK,MAAM,OAAO,cAAc,YAAY;AACzD,kBAAQ,UAAU,OAAO,kBAAkB;AAAA,QAC7C,QAAQ;AACN,kBAAQ,cAAc,KAAK,MAAM;AACjC,kBAAQ,UAAU,IAAI,kBAAkB;AAAA,QAC1C;AAAA,MACF;AAEA,YAAM,cAAc,CAAC,UAAsB;AACzC,cAAM,eAAe;AACrB,cAAM,gBAAgB;AACtB,cAAM,MAAM,OAAO;AAEnB,YAAI,OAAO,MAAM;AACf;AAAA,QACF;AAEA,YAAI,KAAK,QAAQ,SAAS;AACxB,eAAK,QAAQ,QAAQ,MAAM,GAAG;AAAA,QAChC;AAAA,MACF;AAEA,UAAI,KAAK,QAAQ,SAAS;AACxB,gBAAQ,iBAAiB,SAAS,WAAW;AAAA,MAC/C;AAEA,iBAAW;AAEX,aAAO;AAAA,QACL,KAAK;AAAA,QACL,UAAU;AACR,kBAAQ,oBAAoB,SAAS,WAAW;AAAA,QAClD;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF,CAAC;;;AC/RD,SAAS,aAAAA,YAAW,mBAAAC,kBAAiB,QAAAC,aAAY;AAEjD,OAAOC,YAAkC;AAqFlC,IAAM,aAAaD,MAAK,OAA0B;AAAA,EACvD,MAAM;AAAA,EAEN,OAAO;AAAA,EAEP,QAAQ;AAAA,EAER,MAAM;AAAA,EAEN,aAAa;AACX,WAAO;AAAA,MACL,SAAS;AAAA,MACT,cAAc;AAAA,IAChB;AAAA,EACF;AAAA,EAEA,gBAAgB;AACd,WAAO;AAAA,MACL,OAAO;AAAA,QACL,SAAS;AAAA,QACT,WAAW,aAAW,QAAQ,aAAa,YAAY;AAAA,QACvD,YAAY,gBAAc;AACxB,iBAAO;AAAA,YACL,cAAc,WAAW;AAAA,UAC3B;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EAEA,cAAc;AACZ,WAAO;AAAA,MACL,kBACE,aACA,CAAC,EAAE,QAAQ,GAAG,MAAM;AAzH5B;AA0HU,cAAM,QAAQ,QAAQ;AAEtB,cAAM,QAAO,wCAAS,QAAT,YAAgB,OAAO,MAAM,UAAU;AAEpD,YAAI,CAAC,OAAO;AACV,iBAAO;AAAA,QACT;AAEA,WAAG,YAAY,MAAM,MAAM,KAAK,KAAK,OAAO,EAAE,MAAM,CAAC,CAAC;AACtD,eAAO;AAAA,MACT;AAAA,MAEF,kBACE,aACA,CAAC,EAAE,QAAQ,GAAG,MAAM;AAxI5B;AAyIU,cAAM,OAAM,wCAAS,QAAT,YAAgB,OAAO,MAAM,UAAU,MAAM;AACzD,cAAM,OAAO,OAAO,MAAM,IAAI,OAAO,GAAG;AAExC,YAAI,CAAC,QAAQ,KAAK,KAAK,SAAS,KAAK,MAAM;AACzC,iBAAO;AAAA,QACT;AAEA,WAAG,OAAO,KAAK,MAAM,KAAK,QAAQ;AAClC,eAAO;AAAA,MACT;AAAA,MAEF,kBACE,aACA,CAAC,EAAE,QAAQ,GAAG,MAAM;AAClB,cAAM,QAAQ,mCAAS;AACvB,YAAI,MAAM,mCAAS;AAEnB,YAAI,QAAQ,QAAW;AACrB,gBAAM,OAAO,MAAM,UAAU,MAAM;AAAA,QACrC;AAEA,cAAM,OAAO,OAAO,MAAM,IAAI,OAAO,GAAG;AAExC,YAAI,CAAC,QAAQ,KAAK,KAAK,SAAS,KAAK,MAAM;AACzC,iBAAO;AAAA,QACT;AAEA,WAAG,cAAc,KAAK,KAAK,MAAM,EAAE,GAAG,KAAK,OAAO,MAAM,CAAC;AAEzD,eAAO;AAAA,MACT;AAAA,IACJ;AAAA,EACF;AAAA,EAEA,YAAY;AACV,WAAO;AAAA,MACL;AAAA,QACE,KAAK;AAAA,MACP;AAAA,IACF;AAAA,EACF;AAAA,EAEA,WAAW,EAAE,eAAe,GAAG;AAC7B,WAAO,CAAC,QAAQD,iBAAgB,gBAAgB,EAAE,aAAa,cAAc,CAAC,CAAC;AAAA,EACjF;AAAA,EAEA,eAAe,CAAC,UAAe;AAC7B,WAAO;AAAA,MACL,MAAM;AAAA,MACN,OAAO;AAAA,QACL,OAAO,MAAM;AAAA,MACf;AAAA,IACF;AAAA,EACF;AAAA,EAEA,gBAAgB,UAAQ;AAhM1B;AAiMI,UAAM,UAAQ,UAAK,UAAL,mBAAY,UAAS;AAEnC,WAAO,IAAI,KAAK;AAAA,EAClB;AAAA,EAEA,mBAAmB;AAAA,IACjB,MAAM;AAAA,IACN,OAAO;AAAA,IACP,OAAO,CAAC,QAAgB,IAAI,QAAQ,GAAG;AAAA,IACvC,UAAU,CAAC,QAAgB;AAEzB,YAAM,QAAQ,IAAI,MAAM,oBAAoB;AAC5C,UAAI,CAAC,OAAO;AACV,eAAO;AAAA,MACT;AAEA,YAAM,CAAC,WAAW,KAAK,IAAI;AAE3B,aAAO;AAAA,QACL,MAAM;AAAA,QACN,KAAK;AAAA,QACL,OAAO,MAAM,KAAK;AAAA,MACpB;AAAA,IACF;AAAA,EACF;AAAA,EAEA,gBAAgB;AACd,WAAO;AAAA,MACL,IAAID,WAAU;AAAA,QACZ,MAAM;AAAA,QACN,SAAS,CAAC,EAAE,OAAO,OAAO,MAAM,MAAM;AACpC,gBAAM,QAAQ,MAAM,CAAC;AACrB,gBAAM,EAAE,GAAG,IAAI;AACf,gBAAM,QAAQ,MAAM;AACpB,gBAAM,MAAM,MAAM;AAElB,aAAG,YAAY,OAAO,KAAK,KAAK,KAAK,OAAO,EAAE,MAAM,CAAC,CAAC;AAAA,QACxD;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EAEA,cAAc;AACZ,UAAM,EAAE,aAAa,IAAI,KAAK;AAE9B,WAAO,CAAC,EAAE,MAAM,OAAO,MAAM;AAC3B,YAAM,UAAU,SAAS,cAAc,MAAM;AAC7C,cAAQ,YAAY;AAEpB,UAAI,KAAK,OAAO,YAAY;AAC1B,gBAAQ,UAAU,IAAI,qCAAqC;AAAA,MAC7D;AAEA,cAAQ,QAAQ,OAAO;AACvB,cAAQ,aAAa,cAAc,KAAK,MAAM,KAAK;AAEnD,eAAS,aAAa;AACpB,YAAI;AACF,UAAAG,OAAM,OAAO,KAAK,MAAM,OAAO,SAAS,YAAY;AACpD,kBAAQ,UAAU,OAAO,mBAAmB;AAAA,QAC9C,QAAQ;AACN,kBAAQ,cAAc,KAAK,MAAM;AACjC,kBAAQ,UAAU,IAAI,mBAAmB;AAAA,QAC3C;AAAA,MACF;AAEA,YAAM,cAAc,CAAC,UAAsB;AACzC,cAAM,eAAe;AACrB,cAAM,gBAAgB;AACtB,cAAM,MAAM,OAAO;AAEnB,YAAI,OAAO,MAAM;AACf;AAAA,QACF;AAEA,YAAI,KAAK,QAAQ,SAAS;AACxB,eAAK,QAAQ,QAAQ,MAAM,GAAG;AAAA,QAChC;AAAA,MACF;AAEA,UAAI,KAAK,QAAQ,SAAS;AACxB,gBAAQ,iBAAiB,SAAS,WAAW;AAAA,MAC/C;AAEA,iBAAW;AAEX,aAAO;AAAA,QACL,KAAK;AAAA,QACL,UAAU;AACR,kBAAQ,oBAAoB,SAAS,WAAW;AAAA,QAClD;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF,CAAC;;;AF5OM,IAAM,cAAc,UAAU,OAA2B;AAAA,EAC9D,MAAM;AAAA,EAEN,aAAa;AACX,WAAO;AAAA,MACL,eAAe;AAAA,MACf,cAAc;AAAA,MACd,cAAc;AAAA,IAChB;AAAA,EACF;AAAA,EAEA,gBAAgB;AACd,WAAO;AAAA,MACL,UAAU,UAAU,EAAE,GAAG,KAAK,QAAQ,cAAc,cAAc,KAAK,QAAQ,aAAa,CAAC;AAAA,MAC7F,WAAW,UAAU,EAAE,GAAG,KAAK,QAAQ,eAAe,cAAc,KAAK,QAAQ,aAAa,CAAC;AAAA,IACjG;AAAA,EACF;AACF,CAAC;;;AGrDM,IAAM,qBAAqB;AAmB3B,SAAS,6BAA6B,QAAgB,IAAiB,QAAgB,oBAAoB;AAEhH,KAAG,IAAI,YAAY,CAAC,MAAM,QAAQ;AAChC,QAAI,CAAC,KAAK,UAAU,CAAC,KAAK,QAAQ,CAAC,KAAK,KAAK,SAAS,GAAG,GAAG;AAC1D;AAAA,IACF;AAEA,UAAM,EAAE,KAAK,IAAI;AAEjB,UAAM,QAAQ,KAAK,KAAK,MAAM,KAAK;AACnC,QAAI,CAAC,OAAO;AACV;AAAA,IACF;AAEA,UAAM,QAAQ,eAAa;AACzB,YAAM,QAAQ,KAAK,QAAQ,SAAS;AACpC,YAAM,MAAM,QAAQ,UAAU;AAE9B,YAAM,OAAO,GAAG,QAAQ,IAAI,MAAM,KAAK;AAEvC,YAAM,QAAQ,GAAG,IAAI,QAAQ,IAAI;AACjC,YAAM,SAAS,MAAM;AACrB,YAAM,QAAQ,MAAM,MAAM;AAE1B,YAAM,EAAE,WAAW,IAAI,OAAO,OAAO;AAErC,UAAI,CAAC,OAAO,eAAe,OAAO,QAAQ,GAAG,UAAU,GAAG;AACxD;AAAA,MACF;AAGA,SAAG;AAAA,QACD,GAAG,QAAQ,IAAI,MAAM,KAAK;AAAA,QAC1B,GAAG,QAAQ,IAAI,MAAM,GAAG;AAAA,QACxB,WAAW,OAAO,EAAE,OAAO,UAAU,MAAM,GAAG,EAAE,EAAE,CAAC;AAAA,MACrD;AAAA,IACF,CAAC;AAAA,EACH,CAAC;AAGD,KAAG,QAAQ,gBAAgB,KAAK;AAChC,SAAO;AACT;AAqBO,SAAS,mBAAmB,QAAgB,QAAgB,oBAAoB;AACrF,QAAM,KAAK,6BAA6B,QAAQ,OAAO,MAAM,IAAI,KAAK;AACtE,SAAO,KAAK,SAAS,EAAE;AACzB;;;AC7FA,IAAO,gBAAQ;","names":["InputRule","mergeAttributes","Node","katex"]}